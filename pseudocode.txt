class state
class solution
solution == state therefore the "solution" needs to be extracted from a state and be a function?

main {
	x = 1 // The amount of times N-Queens Solution will run to calculate time taken.
	total_time = 0
	
	for i = 0 to x
	{
		// Time for performance the n-queens
		start_time = Start Timing;
		solution = N-Queens(n);
		end_time = end timing;
		
		OutputSolution(solution);
		VerifySolution(solution);
		
		total_time += end_time - start_time;
		
		output the time taken for that solution. "N-Queens Run x: Time Taken: end_time - start_time;
	}

	average_time = total_time / x;
	
	output average_time;		

}


VerifySolution (solution)
{

	for every solution s1
	{
		for every solution s2 (s1 + 1)
		{
			check s1.row != s2.row;
			check s1.column != s2.column;
			check s1.diagonal != s2.diagonal;
			
			if one check fails, fail the output;
			Change console text to red and output failure.
			return false
		}
	}
	return valid solution (ie true)
}

OutputSolution (solution)
{
	parse the solution and convert it to human readable form.
}

NQueens (n)
{
	instantiate state(n);
	instantiate stack; // depth n 
	
	solution = f(state,stack); // recursive function running Nqueens -> a solution = state
	
	return solution
}

f (state, stack)
{
	if stack.depth == n : return state
	
	place queen in next available space.

	// UPDATE MASKS AND DECIDE WHETHER EXIT OR NOT 
	new_mask = mask with quuen
	mask && new_mask != 0 = not valisd state, not goal state so prune branch and exit. 
	mask = state.mask + update to mask (with new queen) -> 

	// Do Recursive 
	
	
}

To switch to long[] need to change the inital call.
line 91 long free = ~(col | diag1 | diag2) & sizeMask;
long currentPos = free & -free;
free -= currentPos;
pos[row] = Long.numberOfTrailingZeros(currentPos);

            //dfs newNode, depth + 1 
            int[] result = dfs(pos, col | currentPos,
               (diag1 | currentPos) << 1,
               (diag2 | currentPos) >> 1, row +1, N);

Question: what if my algorithm is efficient to give very fast times but will break when n>64. Does it have to work for n>64. But it does not matter as fails performance at n~35.
Can i have it switch to just a naive approach at >64 ie 2 DFS to work with n>64 instead of failing but it will likely never solve. 
use seperaste dfs entirely for n >64.

static long[] calculateFreePositions (long[] col, long[] diag1, long[] diag2, int boardCount)
{
	long[] free = new long[boardCount];

	for (int i = 0; i < boardCount; i++)
	{
		if (i == boardCount - 1)
		{
			free[i] = ~(col[i] | diag1 | diag2) & sizeMask;
		} else
		{
			free[i] = ~(col[i] | diag1 | diag2);
		}
	}
}